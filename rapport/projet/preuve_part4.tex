Pour prouver plus facilement la correction des fonctions de l'algorithme de Morris, 
on a commencé par redéfinir un type d'arbre à "plat".
On a donc défini le type \texttt{tree\_shape\_t} : 

\begin{lstlisting}[language=C]
typedef struct tree_shape_t {
    tree_t *cell; // tree node
    int *lchd;    // left child
    int *rchd;    // right child
    int *lmdt;    // leftmost descendant
    int *rmdt;    // rightmost descendant
    int size;
} tree_shape_t;
\end{lstlisting}

On obtient donc un tableau de taille 6 * le nombre de nœuds de l'arbre, et pour chaque nœud
son nœud (pour relier à la forme définie avant), son enfant gauche et droit, 
son enfant le plus à gauche et le plus à droite et enfin la taille de l'arbre.

De plus nous avons défini des variables \emph{ghost} :
\begin{itemize}
    \item \texttt{ghost tree\_shape\_t morris\_t} : arbre "plat"
    \item \texttt{ghost int morris\_r} : indice du nœud à la racine
    \item \texttt{ghost int morris\_c} : nombre de nœuds déjà visités
    \item \texttt{ghost int morris\_k} : indice du nœud courant
    \item \texttt{ghost int warp\_j} : indice du nœud courant dans warp (recherche du nœud le plus à droite du 
    sous-arbre gauche)
    \item \texttt{ghost struct tree *trace[MAX\_NODES]} : tableau contenant les nœuds déjà visités
\end{itemize}

Ces variables \emph{ghost} vont nous aider à écrire les contrats de fonction et donc prouver les fonctions.

Après avoir défini ce type, nous avons traduit l'ensemble des prédicats donnés en \texttt{Why3} par l'article.
Ces prédicats nous serviront ensuite à remplir les contrats de fonction.
On trouve donc les prédicats \texttt{wf\_lst} et \texttt{wf\_rst} qui garantissent que les sous-arbres gauche et droit :
commencent bien juste après i, sont contigus dans le tableau, et correspondent bien aux pointeurs \texttt{left} et \texttt{right} respectivement.
On a aussi le prédicat \texttt{warped\_rst} qui décrit l'arbre comme valide mais dont les pointeurs droits peuvent 
être modifiés.
Puis le prédicat \texttt{frame\_tree} qui indique que seul l'arbre qui lui est passé en argument sera modifié.
Enfin le prédicat \texttt{valid\_tree} qui ressemble à \texttt{valid\_list} et qui confirme que l'arbre est valide 
(donc le nœud courant et ses sous-arbres).

Après cela, nous avons traduit l'ensemble des contrats de fonctions pour les 4 fonctions
(\texttt{warp}, \texttt{morris\_visit}, \texttt{traversal}, \texttt{visit}).
Pour chaque fonction nous avons les \texttt{requires}, \texttt{assigns}, \texttt{ensures} et parfois des variants de boucles : \texttt{decreases}.

Une fois les contrats de fonctions réalisés, nous avons réalisé que les buts étaient trop compliqués
pour le prouveur.
De plus les fonctions étant récursives, les contrats de fonctions doivent être vérifiés à plusieurs reprises.
Pour essayer de simplifier ces preuves, on a donc ajouté des \texttt{assert} dans les fonctions.
Ces \texttt{assert} rajoutent des goals plus faciles à démontrer et aident à montrer les \texttt{requires} du prochain appel
à une fonction.
